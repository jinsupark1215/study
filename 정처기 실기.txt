1장 . 코딩 C java python

2장. 요구사항 확인

:요구사항 개발 프로세스 - 도출, 분석, 명세, 확인

요구사항 도출(수집) : 개발자와 고객 사이의 이해관계자 식별, 의사소통(브레인스토밍, 워크샵, 유스케이스)

요구사항 분석 : 요구사항 중 명확하지 않거나 모호하고 중복되는 부분 제거
기법 - 요구사항 분류(같은 것 끼리), 개념 모델링(단순화시키기), 요구사항 할당, 요구사항 협상, 정형 분석

요구사항 명세 : 체계적 분석 후 문서화

요구사항 확인 : 검토과정
기법 - 요구사항 검토, 프로토타이핑(프로토타입 개발), 모델 검증(요구사항 충족 검증), 인수 테스트(사용자 입장에서 확인)

: UML - 사물(구조, 행동, 그룹, 주해), 관계(집합, 포함, 일반화, 의존, 실체화), 다이어그램(관계도)

유스케이스 다이어그램 : 사용자의 관점에서 수행할 수 있는 기능
활동 다이어그램 : 자료 흐름도, 처리 흐름에 따라 순서대로
클래스 다이어그램 : 객체들을 클래스로 추상화해 표현, 정적 모델링 - 속성, 제약조건, 관계
시퀀스 다이어그램 : 시간의 흐름에 따라 변화하는 과정
커뮤니케이션 다이어그램 : 메시지를 주고받으며 시간의 흐름에 따라 상호작용
상태 다이어그램 : 발생하는 이벤트에 의한 객체들의 상태변화

3장 데이터

: 구성 요소
개체 : 정보
속성 : 논리적 단위로 데이터 항목 또는 데이터 필드
관계 : 관계 또는 속성 간의 논리적인 연결

: 데이터 모델 종류
개념적 데이터 모델 : E-R모델, 개체 타입들 간의 관계를 이용해 현실세계 표현
논리적 데이터 모델 : 현실세계에서 얻은 걸 컴퓨터 환경에 맞게 바꿈
물리적 데이터 모델
데이터 모델에 표시할 요소 : 구조, 연산, 제약 조건

: 이상 - 삽입이상, 삭제 이상, 갱신 이상
: 함수적 종속 - 데이터의 의미를 표현(제약조건)

: 정규화 개념 - 가능한 중복을 제거
제 1 정규형 : 도메인
제 2 정규형 : 부분적 함수적 종속을 완전 함수적 종속으로
제 3 정규형 : 이행적 함수적 종속
BCNF : 결정자이면서 후보키가 아닌 것 제거
제 4 정규형 : 다치 종속
제 5 정규형 : 조인 종속성 이용

: 논리 데이터모델 -> 물리 데이터모델
테이블 : 로우(튜플), 컬럼(속성), 기본키(유일키), 외래키(참조키)
슈퍼타입으로 변환 - 장점 : 액세스 용이, 수행속도 빨라짐, SQL 단순 / 단점 : 컬럼증가로 인해 디스크 저장공간 증가, 인덱스 효율감소
서브타입으로 변환 - 장점 : 선택사양이 명확한 경우 유리, 테이블 크기가 감소해 스캔 시 유리 / 단점 : 속도저하, 복잡한 처리, 유지관리 어려움
개별타입 테이블 변환 - 장점 : 저장공간 적음 / 단점 : 조인발생으로 성능저하

: 반정규화 - 시스템의 성능향상때문, 효율성 증가하지만 일관성(정합성) 저하, 과도하면 오히려 성능저하
테이블 통합, 테이블 분할, 중복테이블 추가, 중복 속성 추가

: 인덱스 - 레코드에 빠르게 접근하기 위해 <키, 포인터> 쌍으로 저장(물리적 구조와 관계)   /   인덱스가 없을 시 Full Scan(Table Scan)이 발생, 기본 인덱스(클러스터드 인덱스)
B트리 인덱스 : 일반적 인덱스 방식으로 루트에서 하위노드로 키 값 비교,오름차순
B+트리 인덱스 : 단말노드인 순차 세트와 아닌 것들로 구분
인덱스 설계 : 분명하게 드러난 컬럼에 대해 기본적 인덱스를 지정 후 필요인덱스
선정 기준 : 분포도가 10~15%, 수정이 빈번하지 않음, order by, group by, union이 빈번한 컬럼

: 뷰 - 가상테이블, 임시작업용, 물리적 구현 X
장점 : 논리적 독립성, 여러 사용자의 상이한 응용 요구지원, 접근 제어
단점 : 독립적 인덱스 X, 삽입,삭제,갱신 연산 제약

: 클러스터 - 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장방법
특징 : 조회 속도는 향상되지만, 입력,수정,삭제에 대한 성능 저하, 데이터 분포도가 넓을 수록 유리, 저장공간 절약

: 파티션 - 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나눔
장점 : 액세스 범위를 줄여 쿼리 성능 향상, 디스크 성능향상, 백업 및 복구 속도 빠름, 데이터 가용성 향상, 분산처리
단점 : 세분화관리, 조인에 대한 비용증가, 파티셔닝 시 성능저하
범위분할(열의 값), 해시 분할(해시함수적용한결과값), 조합분할




4장 통합 구현
: 사용자의 요구사항에 맞춰 송,수신 모듈과 중계 모듈 간의 연계 구현

송신 시스템과 모듈 : 데이터를 생성 및 변환해 전송, 송신모듈과 모니터링 기능
수신 시스템과 모듈 : 데이터를 정제및 변환, 수신모듈과 모니터링
중계 시스템 : 내,외부 시스템 간 연계 시 사용되는 아키텍처
네트워크 : 송,수신 시스템을 연결해주는 통신망

: 연계 메커니즘 : 데이터의 생성 및 전송을 담당하는 송신체계와 수신체계
직접 연계 방식 - 장점 : 구현 단순, 연계처리성능 높음, 비용저렴, 기간짧음 / 단점 : 결합도가 높아 시스템 변경시 오류발생, 보안, 시스템 환경 제한 / 종류 : API, JDBC
간접 연계 방식  - 장점 : 서로 다른 네트워크, 프로토콜 연계 및 통합 가능, 변경되어도 서비스 가능, 보안성 / 아키텍처 복잡, 성능저하, 기간 오래걸림 / 종류 : Socket, Web Service

: 연계 데이터 보안
전송구간 보안 : 데이터나 패킷을 암호화기능이 포함된 프로토콜을 사용
데이터 보안 : 데이터를 추출할 때와 DB에 반영할 때 암,복호화
암호화 알고리즘 : 해시를 이용해 개인키 및 공개키로 양방향 암호화 방식

: 연계 모듈 구현환경
트리거, EAI, ESB 방식과 웹서비스
EAI : 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 솔루션, 시스템 간의 확정성을 높여 준다. / 방식 : Point-to-Point(1:1), hub & spoke, Message bus, hybrid
ESB : 애플리케이션 간 연계, 데이터 변환, 웹서비스 지원, 통합 지향, 애플리케이션 간 결합도를 약하게 유지, 보안 유지 및 관리가 쉽고 높은 품질
웹 서비스 : soap : http같은 프로토콜, UDDI : 검색 및 접근, WSDL : 서비스명

: XML - html 문법이 호환되지 않는 문제와 SGML 복잡함을 해결하기 위한 마크업 언어
직접 태그 정의 가능, 트리구조, 텍스트 형식
SOAP : HTTP/HTTPS 등을 이용해 XML을 교환하기 위한 통신규약, 최근에는 RESTful 프로토콜을 이용 / 요소 : Envelope : 메시지로 정의, Header : 웹서비스를 정의하는 것, Body : 실제 메시지
WSDL : 웹서비스 관련 서식이나 프로토콜을 표준적인 방법으로 기술 및 게시, 서버에서 어떤조작이 가능한지 파악

5장 서버 프로그램 구현
: 하드웨어 환경
웹 서버 : 클라이언트로부터 직접 요청 받아 처리하는 서버
웹 애플리케이션 서버(WAS) : 사용자에게 동적 서비스를 제공하기 위해 웹 서버로부터 요청 받아 데이터 가공 작업 수행, 웹 서버와 파일 서버 사이에서 인터페이스 역할
데이터베이스 서버 : DBMS를 운영하는 서버
파일 서버 : 서비스 제공 목적으로 유지하는 파일 저장
웹 서버 기능 : http/https 지원, 통신 기록, 정적 파일 관리, 대역폭제한, 가상호스팅, 인증
: 소프트웨어 환경
시스템 소프트웨어 : 운영체제, 웹 서버 운용을 위한 서버 프로그램, DBMS
개발 소프트웨어 : 요구사항관리(JIRA), 설계/모델링. 구현 도구(Eclipse), 빌드 도구(Maven), 테스트 도구(SpringTest),형상관리도구(GIT)

: 모듈 - 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위
결합도 : 모듈 간의 상호 의존성. 결합도가 약할수록 품질 높고 강할수록 품질 낮음.   종류 : 자료 < 스탬프 < 제어 < 외부 < 공통(공유) < 내용
응집도 : 모듈 내부 요소의 관련정도. 모듈이 독립적인 기능으로 정의된 정도                     종류 : 기능적 > 순차적 > 교환적 > 절차적 > 시간적 > 논리적 > 우연적
Fan-In 이 많으면 잘 설계됨. 관리 및 테스트 필요, Fan-Out이 많으면 다른 모듈 호출하는지 단순화 시킬 수 있는지 여부 검토
효율적 모듈 설계 방안 : 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높인다. / 복잡도와 중복성을 줄이고 일관성 유지 / 유지보수 용이

: DBMS 접속 - 사용자가 데이터를 사용하기 위해 응용시스템을 이용해 DBMS 접근
웹 응용 시스템 : 웹 서버 + WAS
접속 기술 : JDBC(Java 언어의 API), ODBC(데이터베이스 표준 API), MyBatis(JDBC 코드를 단순화해 SQL Mapping 기반 오픈소스 접속 프레임워크)
동적 SQL : 다양한 조건에 따라 SQL 구문을 동적으로 변경하여 처리, NVL 함수 사용 필요 X, 프리컴파일 할 때 구문 분석, 접근 권한 확인 등 할 수 없다.

: 서버 개발 - 서버프로그램을 제작하여 웹 애플리케이션 서버(WAS)에 탑재하는 것, 웹 서버로 부터 받은 요청을 처리하여 결과를 반환하는 역할
서버 개발 프레임워크 : Spring(java), Node.js(javaScript, 비동기 입,출력, 이벤트 위주의 높은 처리성능으로 애플리케이션 적합), Django(Python), Ruby, Codeigniter
프레임워크 특성 : 모듈화(캡슐화로 설계 및 구현의 변경에 영향 최소화), 재사용성, 확장성, 제어의 역흐름

: 서버 개발 과정 - DTO/VO, SQL, DAO, Service, Controller
DTO/VO 는 데이터 교환을 위해 사용할 객체 만듦, 데이터의 자료형에 맞게 생성
SQL 구현은 데이터 삽입,변경,삭제 작업수행
DAO 구현은 데이터베이스에 접근하고 SQL 활용해 데이터 조작
Service 구현은 사용자의 요청에 응답하기 위한 로직구현
Controller 구현은 사용자의 요청에 적절한 서비스를 호출하고 결과를 사용자에게 반환

: 배치 프로그램 - 정기 배치, 이벤트성 배치, On-Demand 배치
필수 요소 : 대용량 데이터, 자동화, 견고성, 안정성, 성능
배치 스케줄러 : 스프링 배치(Job, Job Launcher, Step, Job Repository), Quartz(스프링 프레임워크로 개발되는 프로그램 일괄처리), Cron(리눅스 스케줄러)





6장 화면 설계

: 사용자 인터페이스(UI)
정보 제공과 전달을 위한 물리적 제어, 콘텐츠의 상세적인 표현과 전체적인 구성, 모든 사용자가 편리하고 간편하게 사용하도록 하는 기능
특징 : 사용자의 편리성과 가독성을 높임으로 시간단축 및 업무이해도 증진
구분 : CLI(명령과 출력), GUI(아이콘이나 메뉴선택), NUI(말이나 행동으로 조작)
기본 원칙 : 직관성, 유효성, 학습성, 유연성
설계 지침 : 사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류 발생 해결
설계 도구 : 와이어프레임, 목업, 스토리보드, 프로토타입, 유스케이스

: UI 표준 및 지침
UI 표준 : 모든 UI에 공통적 적용될 내용, 화면 구성이나 화면 이동이 포함
UI 지침 : UI 요구사항, 구현 시 제약사항 등 개발과정에서 꼭 지켜야할 조건
웹의 3요소 : 웹 표준, 웹 접근성, 웹 호환성
구동환경 정의 : 프레임 세트(화면 해상도, 크기에 따라 프레임 구분)
레이아웃 정의 : 화면 구조를 정의하고 각 영역의 메뉴를 구성
네비게이션 정의 : 원하는 정보를 빠르게 찾을 수 있도록 안내
기능 정의 : 필요한 데이터 간의 관계 등을 논리적인 모델로 상세화
구성요소 정의 : 그리드나 버튼을 정의

: UI 요구사항 확인
목표 정의 : 사용자 인터뷰 후 사용자의 의견이 수렴된 요구사항 정의
활동 사항 정의 : 해야할 활동 사항 정의
UI 요구사항 작성 : UI 개발 목적에 맞게 작성
요구사항 요소 확인 : 데이터 요구, 기능 요구, 제품/서비스의 품질, 제약사항
정황 시나리오 작성 : 목표를 달성하기 위해 방법을 순차적으로 묘사
요구사항 작성 : 정황 시나리오를 토대로 작성

: UI 프로토타입 - 실제 동작하는 것처럼 만든 동적인 형태의 모형
장점 : 사용자 설득과 이해가 쉽다. 요구사항 불일치로 인한 혼선예방,개발시간 줄임
단점 : 작업시간이 증가하고 필요이상 자원 소모
종류 : 페이퍼 프로토타입, 디지털 프로토타입

: UI 흐름 설계 - 진행과정이나 수행 절차에 따른 흐름을 파악해 화면과 폼을 설계
기능 작성 : 화면에 표현할 기능을 작성하는 단계(기능적/비기능적 요구사항)
입력 요소 확인 : 화면에 표현되어야 할 기능을 확인한 후 입력할 요소 확인
유스케이스 설계 : UI 유스케이스 설계
기능 및 양식 확인 : 텍스트박스,콤보박스 등 규칙 정의
: UI 상세 설계 - 자세한 설계
요구사항 확인 : 요구사항을 최종적으로 확인
UI 설계서 표지 및 개정 이력 작성 : 다른 문서와 혼동되지 않도록 작성
UI구조 설계 : 요구사항과 프로토타입에 기초해 UI 구조 설계
메뉴 구조 설계 : 사이트맵 구조를 통해 사용자 기반 메뉴구조를 설계
화면 설계 : 필요한 화면 설계
7장 애플리케이션 테스트
: 요구사항을 만족시키는지 확인, 기능을 정확히 수행하는지 검증
필요성 : 오류 예방, 신뢰도 향상
*기본 원리 : 완벽한 테스트 불가능, 결함 집중(파레토 법칙), 살충제 파라독스(내성 생김), 테스팅은 정황 의존, 오류 부재의 궤변, 테스트와 위험은 반비례, 점진적 확대, 별도 팀 수행

:테스트 분류
정적 테스트 : 명세서나 소스 코드 대상으로 분석(워크스루, 인스펙션, 코드검사)
동적 테스트 : 실행하여 오류를 찾는 테스트(블랙박스, 화이트박스 테스트)
테스트 기반에 따른 테스트 : 명세 기반 테스트(동등 분할, 경계값분석), 구조 기반 테스트(내부의 논리흐름에따라), 경험 기반 테스트(테스터의 경험을 기반, 에러추정)
검증 테스트(개발자 시각), 확인테스트(사용자 시각)
회복 테스트(결함을 주어 실패하게하고 복구하는지), 안전 테스트(불법적인 침입으로부터 시스템을 보호할 수 있는지), 강도 테스트(과부하를 걸어 진단), 성능테스트(실시간 성능이나 효율성 진단), 구조테스트(논리적인 경로 진단), 회귀 테스트(변경, 수정된 코드에 결함이 없는지), 병행테스트(변경된 소프트웨어와 기존이 동일한 결과값인지 진단)

: 화이트박스 테스트 - 모듈의 원시코드를 오픈시킨 상태에서 논리적인 모든 경로 테스트
	종류
기초 경로 검사 : 논리적 복잡성을 측정할 수 있게하는 테스트
제어 구조 검사 : 조건검사(모든 논리적 조건을 테스트), 루프 검사(반복 구조에 초점), 데이터 흐름 검사(변수의 정의와 사용의 위치에 초점) 
검증 기준
문장 검증 기준 : 모든 구문이 한 번 이상 수행
분기 검증 기준 : 모든 조건문이 한번 이상 수행
조건 검증 기준 : 모든 조건문에 대해 true와 false 인 경우 한번이상 수행
분기/조건 기준 : 모든 조건문과 true/false가 한번이상 수행

: 블랙박스 테스트 - 각 기능이 완전히 작동되는지 입증, 기능테스트
	종류
동치 분할 검사 : 테스트케이스를 만들고 검사, 입력조건에 맞게 자료의 갯수가 동등하게 만들어 검사
경계값 분석 : 경계값 테스트
원인-효과 그래프 검사 : 데이터 간 관계와 출력에 영향을 미치는 상황 분석
오류 예측 검사 : 과거의 경험이나 확인자의 감각으로 테스트
비교 검사 : 여러 버전의 프로그램과 동일한 테스트 자료

: 개발 단계에 따른 테스트 
단위 테스트 : 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트(기능성 테스트를 최우선, 구조기반테스트(화이트박스)와 명세기반테스트(블랙박스))
통합 테스트 : 하나의 시스템으로 완성시키는 과정에서의 테스트
시스템 테스트 : 해당 컴퓨터 시스템에서 완벽하게 수행되는지 테스트(기능적 요구사항(명세 기반의 블랙박스), 비기능적 요구사항(구조적 요소의 화이트박스))
인수 테스트 : 요구사항에 충족하는지에 중점을 두고 테스트(사용자 인수테스트(적절성 여부), 운영상 인수 테스트(관리자가 수행하는 테스트), 계약 인수 테스트(계약테스트), 규정 인수 테스트(정부지침,법규), 알파테스트(개발자 앞에서 행하는 테스트), 베타테스트(선정된 최종 사용자 테스트))

: 통합 테스트
비점진적 통합 방식 : 단위 테스트가 끝난 모든 모듈을 한꺼번에 결합시켜 테스트하는 방식. 규모가 작은 소프트웨어에 유리하고 단기간에 테스트 가능(빅뱅 통합 테스트)
점진적 통합 방식 : 모듈 단위로 단계적으로 통합하며 하향식, 상향식, 혼합식이 있음. 오류 수정에 용이하고 연관된 오류테스트 가능
하향식 통합 테스트 : 상위 모듈에서 하위모듈 방향으로 통합하며 테스트(dfs, bfs), 사용자에게 시스템 구조를 보여줄 수 있다.(스텁, 회귀테스트 가능)
상향식 통합 테스트 : 하위 모듈에서 상위 모듈 방향으로 통합. (하위 모듈을 클러스터로 결합하고 드라이버 작성)
혼합식 통합 테스트 : 샌드위치식 통합 테스트
회귀 테스트 : 이미 테스트된 프로그램의 테스팅을 반복(수정한 모듈이나 컴포넌트가 다른 부분에 영향을 미치는지 오류가 생기지 않았는지)

: 애플리케이션 테스트 프로세스
테스트 계획 > 테스트 분석 > 테스트 케이스 > 테스트 시나리오 > 테스트 결과서
테스트 계획 : 명세 기반으로 테스트 목표를 정의하고 테스트 대상 및 범위결정
테스트 분석 : 테스트 목적과 원칙을 검토하고 사용자의 요구사항 분석
테스트 케이스 및 시나리오 작성 : 설계 기법에 따라 작성
테스트 결과 평가 및 리포팅 : 결과를 비교 분석하여 결과서 작성
결함 추적 및 관리 : 결함 추적

: 테스트 케이스 - 요구사항을 정확하게 준수했는지 확인하기 위해 입력값, 실행조건, 기대결과
테스트 계획 검토 및 자료확보 > 위험 평가 및 우선순위 결정 > 요구사항 정의 > 구조 설계 및 방법 결정 > 테스트케이스 정의 > 타당성 확인 및 유지보수
테스트 오라클 : 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값 대입     특징 : 제한된 검증, 수학적 기법, 자동화 가능 / 종류 : 참 오라클, 샘플링 오라클, 추정 오라클, 일관성 검사 오라클

: 테스트 자동화 - 테스트 절차를 스크립트 형태로 구현, 휴먼 에러를 줄이고 테스트 정확성을 유지하고 테스트의 품질을 향상
장점 : 인력 및 시간 줄임, 다중 플랫폼 호환성, 요구사항 일관성있게 검증, 결과를 그래프 등 다양한 표시형태
단점 : 사용방법에 대한 교육 및 학습, 시간과 비용과 노력이 필요, 고가의 추가비용
유형 : 정적분석도구, 테스트 실행 도구, 성능 테스트 도구, 테스트 통제도구, 테스트 하네스 도구

:결함 관리 - 결함은 설계한 것과 다르게 동작하거나 다른 결과 발생
결함 관리 프로세스 : 결함관리 계획, 결함 기록, 결함 검토, 결함 수정, 결함 재확인, 결함 상태 추적 및 모니터링 활동, 결함 분석 및 보고서 작성
결함 추적 순서 : 결함 등록 > 결함 검토 > 결함 할당 > 결함 수정 > 결함 조치 보류 > 결함 종료 > 결함 해제
결함 심각도 : high(핵심 요구사항 미구현, 장시간 시스템 응답 지연, 시스템 다운), medium(부정확한 기능이나 데이터베이스 에러), Low ( 부정확한 GUI 및 메시지, 문법/철자 오류 등 시스템 흐름에 영향을 미치지 않음)

: 성능 분석
측정 지표 : 처리량, 응답 시간, 경과 시간, 자원 사용률
성능 테스트 도구 : JMeter, LoadUI, OpenSTA
시스템 모니터링 도구 : Scouter, Zabbix
주요 원인 : connection 객체를 생성하거나 쿼리를 실행할 때 많이 발생(데이터베이스 락 걸린 경우, 커넥션 풀의 크기가 너무 작거나 크게 설정한 경우, 연결 누수가 발생한경우, 트랜잭션이 확정되지 않고 커넥션 풀에 반환되거나 불필요한 Commit이 발생하는 경우, 서버 소켓 불량)

: 성능 개선 - 코드 최적화
클린 코드 작성 원칙 : 가독성(쉽게), 단순성(간단), 의존성 배제(다른 모듈에 미치는 영향 최소), 중복성 최소화(중복최소), 추상화(상위클래스는 간단, 상세내용은 하위클래스)
최적화 유형 : 클래스 분할 배치(응집도 높이고 크기 작게), Loosely Coupled(느슨한 결합, 인터페이스 클래스를 이용해 추상화), 코딩 형식 준수), 좋은 이름 사용, 적절한 주석문 사용
분석 도구 : 정적 분석(코딩 스타일이나 코딩을 보고 분석), 동적 분석(실행해 존재하는 메모리 누수, 스레드 결함 분석)

8장 SQL 응용
: DDL(데이터 정의어) - Create, Alter, Drop
Create SCHEMA, DOMAIN, TABLE, VIEW, INDEX
[DEFAULT 기본값][NOT NULL] : 기본값
 [PRIMARY KEY(기본키)]  : 기본키 속성
[UNIQUE(대체키)] : 대체키 속성
[FOREIGN KEY(외래키)] : 외래키 속성, 외래키 지정되면 참조무결성의 CASCADE 법칙 적용
[CONSTRAINT 제약조건명] : 제약조건
[CHECK(조건식)] : 속성 값에 대한 제약조건
ALTER TABLE
ADD : 새로운 속성(열) 추가할 때
ALTER : 특정 속성의 DEFAULT 값 변경시
DROP COLUMN : 특정 속성 삭제
DROP : 삭제

:DCL (데이터 제어어) - GRANT/REVOKE, COMMIT, ROLLBACK, SAVEPOINT
GRANT : 권한부여
REVOKE : 권한 취소
권한 종류 : ALL, SELECT, INSERT, DELETE, UPDATE, ALTER
COMMIT : 트랜잭션이 성공적으로 끝나면 새로운 일관성 상태를 가짐.
ROLLBACK : 변경된 모든 내용을 취소하고 이전상태로 되돌림
SAVEPOINT : 저장점을 지정

: DML (데이터 조작어) : SELECT, INSERT, DELETE, UPDATE
INSERT INTO 테이블명(속성명1,~~~) VALUES(데이터1,데이터2)
DELETE FROM FROM 테이블명 [WHERE 조건];
UPDATE 테이블명 SET 속성명 = 데이터[,속성명=데이터 ~~] [WHERE 조건]
SELECT 속성명 [AS 별칭][, [테이블명] 속성명 ~] [그룹함수(속성명)][WINDOW함수]
FROM 테이블명[, 테이블명~]
[WHERE 조건]
[GROUP BY 속성명, 속성명, ~]
[HAVING 조건]
[ORDER BY 속성명 [ASC | DESC]];
ALL : 모두 검색, 주로 생략 / DISTINCT : 중복된 튜플이 있으면 하나만  /  DISTINCTROW : 중복된 튜플 제거하고 튜플 전체 대상 / 전체 속성 검색시 *, 두 개 이상의 테이블을 대상으로 할 때 테이블명.속성명
그룹 함수 : GROUP BY에 지정된 그룹별로 속성의 값을 집계
WINDOW 함수 : GROUP BY를 이용하지 않고 속성 값 집계

: 프로시저 - 절차형 SQL을 활용하여 트랜잭션 언어, 미리 저장해 놓은 SQL
DECLARE : 프로시저의 명칭, 변수, 인수, 데이터 타입 선언
BEGIN / END : 시작과 종료
CONTROL : 조건문 또는 반복문이 삽입되어 순차적 처리
SQL : 조회,추가,수정,삭제 수행
EXCEPTION : 예외 처리
TRANSACTION : DB 적용할지 취소할지 결정
CREATE [OR REPLACE] PROCEDURE 프로시저명(파라미터) [지역변수 선언]
BEGIN 프로시저 BODY;END;
파라미터 : IN(값 전달), OUT(값 반환), INOUT(값전달하고반환)
실행 : CALL, EXEC
제거 : DROP PROCEDURE
반환값 없거나 1개이상,입출력,DML,DCL,실행문

: 트리거 - 삽입,갱신,삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동 수행되는 SQL
목적 : 데이터 무결성 유지, 로그 메시지 출력 
DCL 사용 불가
CREATE 
[OR REPLACE] : 이미 존재하면 기존의 트리거 대체
 TRIGGER 트리거명
[동작시기 옵션] : 트리거 실행될 때 지정
[동작 옵션] : 트리거가 실행되게 할 작업의 종류
ON 테이블명
REFERENCING [NEW | OLD] AS 테이블명 : 트리거 적용될 별칭
FOR EACH ROW : 튜플마다 트리거 적용
[WHEN 조건식] BEGIN 트리거 BODY; END;
트리거 제거 : DROP TRIGGER 트리거명

: 사용자 정의 함수 - 프로시저와 유사하게 SQL로 일련의 작업을 연속적 처리
SELECT 조회만 가능
프로시저 호출 사용 X
SUM(),AVG() 등의 내장함수 반환값을 활용하기 위한 용도
CREATE [OR REPLACE] FUNCTION 
사용자 정의 함수명(파라미터) : IN(값을 전달)
[지역변수 선언]
BEGIN 사용자 정의 함수 BODY; RETURN 반환값; END;
DROP FUNCTION 사용자 정의 함수명;
반환값 1개, 입력만 가능, SELECT, DML에 포함

: 제어문 - IF, LOOP, GOTO
IF 조건 THEN : 조건1이 참일 경우
실행 문장1 ~~
ELSIF 조건2 THEN : 조건2가 참일경우
실행문장2
ELSE
실행문장 3 : 조건이 거짓일 경우
END IF;
LOOP
FOR 변수 IN 초기값.. 종료값
실행문장;
EXIT WHEN 조건;
END LOOP
WHILE 조건
LOOP 실행문장;
END LOOP;
CONTINUE WHEN 조건 : 이후 문장은 실행하지 않고 반복문의 처음으로 옮김
GOTO 레이블 : 명령문을 수행하기 위해 사용하는 제어문
<<레이블>>
실행 문장;

: 커서 - 처리 결과가 저장되어 있는 메모리 공간을 가리키는 포인터
